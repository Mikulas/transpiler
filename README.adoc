:toc: macro
:!toc-title:
:source-language: php

++++
<a href="#transpiler"><img height="150" src="https://mikulas.github.io/assets/transpiler.svg" align="right" /></a>
++++
= Transpiler

PHP source code transformations.

image:https://circleci.com/gh/Mikulas/transpiler.svg?style=svg&circle-token=95af859daa8a8d404100caf22e52269e447012f3["CircleCI", link="https://circleci.com/gh/Mikulas/transpiler"]

toc::[]

== What Is It Good For?

By transpiling code to older runtime versions you gain
many benefits of PHP 7.1 such as void return types and
optionals (which are mostly useful for static analysis),
but you are not forced to update production to unstable
bleeding-edge versions.

== Implemented AST modifiers:

=== PHP 7.1 -> 7.0

http://php.net/manual/en/migration71.new-features.php

==== Remove void return types

```
function foo(): void
{
}

# -->

function foo()
{
}
```

__Limitations:__ `ReflectionFunctionAbstract::getReturnType()` and `hasReturnType()` will return `NULL` and `FALSE` respectively instead of original values.

==== Remove class constant visibilities

```
class Foo
{
    public const A = 'a';
    protected const B = 'b';
    private const C = 'c';
}

# -->

class Foo
{
    const A = 'a';
    const B = 'b';
    const C = 'c';
}
```

__Limitations:__ none

==== Rollout named assignment

```
['X' => ['A' => $a, 'B' => $b]] = ['X' => ['A' => 10, 'B' => 20]];
list('T' => list('U' => $u, 'V' => $v)) = ['T' => ['U' => 15, 'V' => 19]];

while (list($a, $b) = $right) {
    block();
}
# -->

${'~transpiler-1'} = ['X' => ['A' => 10, 'B' => 20]];
$a = ${'~transpiler-1'}['X']['A'];
$b = ${'~transpiler-1'}['X']['B'];

${'~transpiler-2'} = ['T' => ['U' => 15, 'V' => 19]];
$u = ${'~transpiler-2'}['T']['U'];
$v = ${'~transpiler-2'}['T']['V'];

while (${'~transpiler-3'} = $right) {
    $a = ${'~transpiler-3'}[0];
    $b = ${'~transpiler-3'}[1];
    block();
}
```

__Limitations:__ slightly worse performance, introduces new variable

Dynamic mutating keys are not supported.
```
[$x++ => $a, $x++ => $b] = [10, 20];
```

=== Remove nullable return type

```
function sum(): ?int
{
}

# -->

function sum()
{
}
```

=== Convert nullable parameter

```
function sum(?int $a, ?int $b)
{
}

# -->

function sum(int $a = NULL, int $b = NULL)
{
}
```

=== Remove iterable type

```
function compute(iterable $arr): iterable
{
}

# -->

function compute($arr)
{
}
```


=== Convert `Closure::fromCallable`

```
Closure::fromCallable('intdiv');
Closure::fromCallable([$foo, 'bar']);
Closure::fromCallable([Foo::class, 'qaz']);
Closure::fromCallable($foo($a = $b));

# -->

function () {
    return call_user_func_array('intdiv', func_get_args());
};

function () use(&$foo) {
    return call_user_func_array([$foo, 'bar'], func_get_args());
};

function () {
    return call_user_func_array([Foo::class, 'qaz'], func_get_args());
};

function () use(&$foo, &$a, &$b) {
    return call_user_func_array($foo($a = $b), func_get_args());
};
```

__Limitations:__ FQN is not resolved, so aliases to Closure do not work. Dynamic invocation does not work either (such as from `call_user_func`).


=== Expand multi catch exception handlers

```
try {
} catch (FooException | BarException $e) {
    handler();
}

# -->

try {
} catch (FooException $e) {
    handler();
} catch (BarException $e) {
    handler();
}
```
